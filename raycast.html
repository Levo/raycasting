<head>
    <script type="text/javascript" src="class.js"></script>
    </head>
    <body style="margin:0; padding:0;">
      <canvas id="myCanvas" width='512' height='384' style="background-color:black;"></canvas>
      <script>
            window.requestAnimFrame = (function(callback) {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
              window.setTimeout(callback, 1000 / 60);
            };
          })();

        var canvas = document.getElementById('myCanvas');
        var context = canvas.getContext('2d');

        var pos = {x: 22, y: 12}; // x and y start position
        var dir = {x: -1, y: 0}; // initial direction vector
        var plane = {x: 0, y: 0.66}; //the 2d raycaster version of camera plane

        var width = canvas.width;
        var height = canvas.height;

        var Time = 0;
        var oldTime = 0;

        var moveSpeed;
        var rotSpeed;


        var worldMap = [
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
          [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1],
          [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        function drawVertLines(x,y1,y2,color){
          context.beginPath();
          context.strokeStyle = color;
          context.moveTo(x, y1);
          context.lineTo(x, y2);
          context.stroke();
        }
      

        function animate(canvas, context,startTime) {
            var time = (new Date()).getTime() - startTime;
            var currentTime = Date.now();


            context.clearRect(0, 0, canvas.width, canvas.height);

            for (var x = 0; x < width; x++) {
                var cameraX = 2 * x / width - 1; //x coordinate in camera space
                rayPos = {x: pos.x, y: pos.y};
                rayDir = {x: dir.x + plane.x * cameraX, y: dir.y + plane.y * cameraX};

                // Which box of the map we are in
                var map = {x: Math.floor(rayPos.x), y: Math.floor(rayPos.y)};
                var sideDist = {x: null, y: null};
                var deltaDist = {x: Math.sqrt(1 + (rayDir.y * rayDir.y) / (rayDir.x * rayDir.x)), y: Math.sqrt(1 + (rayDir.x * rayDir.x) / (rayDir.y * rayDir.y))};
                var perpWallDist = null;

                var step = {x: null, y: null};

                var hit = 0; // wall hit?
                var side = null; // NS or EW wall hit?

                // calculate step and initial side dist
                if( rayDir.x < 0 ){
                    step.x = -1;
                    sideDist.x = (rayPos.x - map.x) * deltaDist.x;
                }else{
                    step.x = 1;
                    sideDist.x = (map.x + 1.0 - rayPos.x) * deltaDist.x;
                }

                if( rayDir.y < 0 ){
                    step.y = -1;
                    sideDist.y = (rayPos.y - map.y) * deltaDist.y;
                }else{
                    step.y = 1;
                    sideDist.y = (map.y + 1.0 - rayPos.y) * deltaDist.y;
                }

                // DDA

                while(hit == 0){
                    if(sideDist.x < sideDist.y){
                        sideDist.x += deltaDist.x;
                        map.x += step.x;
                        side = 0;
                    }else{
                        sideDist.y += deltaDist.y;
                        map.y += step.y;
                        side = 1;
                    }
                    if(worldMap[map.x][map.y] > 0){
                        hit = 1;
                    }
                }

                if (side == 0){
                    perpWallDist = Math.abs( (map.x - rayPos.x + (1 - step.x) / 2) / rayDir.x );
                }else{
                    perpWallDist = Math.abs( (map.y - rayPos.y + (1 - step.y) / 2) / rayDir.y );
                }

                var lineHeight = Math.abs(height / perpWallDist);

                var drawStart = -lineHeight / 2 + height / 2;
                if(drawStart < 0){
                    drawStart = 0;
                }
                var drawEnd = lineHeight / 2 + height / 2;
                if(drawEnd >= height){
                    drawEnd = height - 1;
                }

                var color = null;
                switch(worldMap[map.x][map.y]){
                    case 1: color = 'rgb(255,0,0)';
                                    break;
                    case 2: color = 'rgb(0,255,0)';
                                    break;
                    case 3: color = 'rgb(0,0,255)';
                                    break;
                    case 4: color = 'rgb(255,255,255)';
                                    break;
                    default: color = 'rgb(255,255,0)';
                                    break;
                }

                if (side == 1){
                    color = 'gray';
                }

                drawVertLines(x,drawStart,drawEnd,color);

            };
            oldTime = Time;
            Time = time;
            var frameTime = (Time - oldTime)/1000;
            context.beginPath();
            context.fillStyle = 'white';
            context.fillText(Math.floor(1/frameTime), 25, 25);
            context.fill();
            context.closePath();
            // W 87
            // A 65
            // S 83
            // D 68
            moveSpeed = frameTime * 5.0;
            rotSpeed = frameTime * 3.0;

            requestAnimFrame(function() {
              animate(canvas, context, startTime);
            });

            document.onkeydown = function(event){     
              if(event.keyCode == '87') { // Moving foward
                var posX1 = Math.floor(pos.x + dir.x * moveSpeed);
                var posY1 = Math.floor(pos.y);

                var posX2 = Math.floor(pos.x);
                var posY2 = Math.floor(pos.y + dir.y * moveSpeed);

                if(worldMap[posX1][posY1] == false) {pos.x += (dir.x * moveSpeed)};
                if(worldMap[posX2][posY2] == false) {pos.y += (dir.y * moveSpeed)};
              }

              if(event.keyCode == '83') {
                var posX1 = Math.floor(pos.x - dir.x * moveSpeed);
                var posY1 = Math.floor(pos.y);

                var posX2 = Math.floor(pos.x);
                var posY2 = Math.floor(pos.y - dir.y * moveSpeed);

                if(worldMap[posX1][posY1] == false) {pos.x -= (dir.x * moveSpeed)};
                if(worldMap[posX2][posY2] == false) {pos.y -= (dir.y * moveSpeed)};

              }

              if(event.keyCode == '68') {
                var oldDirX = dir.x;
                dir.x = dir.x * Math.cos(-rotSpeed) - dir.y * Math.sin(-rotSpeed);
                dir.y = oldDirX * Math.sin(-rotSpeed) + dir.y * Math.cos(-rotSpeed);
                var oldPlaneX = plane.x;
                plane.x = plane.x * Math.cos(-rotSpeed) - plane.y * Math.sin(-rotSpeed);
                plane.y = oldPlaneX * Math.sin(-rotSpeed) + plane.y * Math.cos(-rotSpeed);
              }

              if(event.keyCode == '65') {
                var oldDirX = dir.x;
                dir.x = dir.x * Math.cos(rotSpeed) - dir.y * Math.sin(rotSpeed);
                dir.y = oldDirX * Math.sin(rotSpeed) + dir.y * Math.cos(rotSpeed);
                var oldPlaneX = plane.x;
                plane.x = plane.x * Math.cos(rotSpeed) - plane.y * Math.sin(rotSpeed);
                plane.y = oldPlaneX * Math.sin(rotSpeed) + plane.y * Math.cos(rotSpeed);
              }


            }




        }

        setTimeout(function() {
            var startTime = (new Date()).getTime();
            animate(canvas, context,startTime);
          }, 1000);
      </script>
</body>